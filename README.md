# goit-algo-hw-09

## Greedy algorithms and dynamic programming

## Порівняння жадібного алгоритму та динамічного програмування

У цьому домашньому завданні було розроблено та порівняно два алгоритми для видачі решти монетами номіналом `[50, 25, 10, 5, 2, 1]`: **Жадібний алгоритм та Алгоритм динамічного програмування**.

1. **Жадібний алгоритм** (`find_coins_greedy`)

Цей підхід працює за принципом вибору монети найбільшого можливого номіналу на кожному кроці, поки сума не буде набрана.

-   **Часова складність:** $O(N)$, де $N$ — кількість номіналів монет. Оскільки кількість номіналів фіксована (6 штук), можна вважати складність $O(1)$. Алгоритм виконує фіксовану кількість операцій незалежно від суми.
-   **Просторова складність:** $O(1)$ — потребує мінімум пам'яті для зберігання змінних.
-   **Ефективність:** Працює миттєво для будь-яких сум (навіть дуже великих, наприклад, 1 млрд), оскільки базується на простих математичних операціях ділення.

2. **Динамічне програмування** (`find_min_coins`)

Цей підхід розбиває задачу на менші підзадачі, знаходячи мінімальну кількість монет для кожної суми від `1` до заданої `amount`.

-   **Часова складність:** $O(A \cdot N)$, де $A$ — сума решти, а $N$ — кількість номіналів. Час виконання лінійно зростає зі збільшенням суми.
-   **Просторова складність:** $O(A)$ — потребує створення масиву (або хеш-таблиці) розміром `amount + 1` для збереження проміжних результатів.
-   **Ефективність:** Для малих сум працює швидко. Однак для великих сум (наприклад, > 100 000) час виконання значно зростає, а споживання оперативної пам'яті може стати критичним, що призведе до збоїв або надзвичайно довгої роботи.

**Порівняльна таблиця**

| Характеристика               | Жадібний алгоритм            | Динамічне програмування                  |
| :--------------------------- | :--------------------------- | :--------------------------------------- |
| **Швидкість**                | Дуже швидко (миттєво)        | Залежить від суми (повільніше)           |
| **Складність (Big O)**       | $O(N)$ або $O(1)$            | $O(A \cdot N)$                           |
| **Пам'ять**                  | Мінімальна                   | Значна (пропорційна сумі)                |
| **Оптимальність**            | Не завжди гарантує мінімум\* | **Завжди** гарантує мінімальну кількість |
| **Робота з великими сумами** | Відмінно                     | Погано (ризик переповнення пам'яті)      |

**Чому жадібний алгоритм ефективніший у цьому випадку?**

У нашому прикладі використовується набір монет `[50, 25, 10, 5, 2, 1]`. Ця система є **канонічною**.

-   **Канонічна система монет** — це така система, в якій жадібний алгоритм завжди гарантує знаходження оптимального рішення (мінімальної кількості монет).

Саме тому результати роботи обох функцій однакові, але жадібний алгоритм виграє за часом та ресурсами.

**Коли варто використовувати динамічне програмування?**

Динамічне програмування стає необхідним, коли набір монет **не є канонічним**.
Наприклад, для набору `[9, 6, 1]` та суми 12:

1. Жадібний алгоритм видасть: `9 + 1 + 1 + 1` (4 монети).
2. Динамічне програмування знайде: `6 + 6` (2 монети).

**Висновок:** Для касових апаратів зі стандартними валютами жадібний алгоритм є кращим вибором через його швидкодію. Метод динамічного програмування є універсальним інструментом для складніших оптимізаційних задач, де проста логіка не спрацьовує.
